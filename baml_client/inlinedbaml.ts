/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
const fileMap = {
  
  "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\nclient<llm> GPT4o {\n  provider openai\n  options {\n    model \"gpt-4o\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> GPT4oMini {\n  provider openai\n  options {\n    model \"gpt-4o-mini\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\nclient<llm> Sonnet {\n  provider anthropic\n  options {\n    model \"claude-3-5-sonnet-20240620\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\n\nclient<llm> Haiku {\n  provider anthropic\n  options {\n    model \"claude-3-haiku-20240307\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> Fast {\n  provider round-robin\n  options {\n    // This will alternate between the two clients\n    strategy [GPT4oMini, Haiku]\n  }\n}\n\nclient<llm> Openai {\n  provider fallback\n  options {\n    // This will try the clients in order until one succeeds\n    strategy [GPT4o, GPT4oMini]\n  }\n}",
  "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"typescript\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.55.3\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode async\n}\n",
  "graphql-query.baml": "\n\n\n\nfunction GenerateGraphQLQuery(query: string, schema: string, url: string) -> string {\n  client Sonnet\n  prompt #\"\n    Generate a graphql query for the following request.\n    ---\n    Request: {{query}}\n    ---\n\n    Here is the schema of the graphql database:\n    {{schema}}\n\n\n     Format guidelines:\n    - Answer with a curl request the user can make to get the data they want. The endpoint is {{url}}.\n    - Do not include any other text in your response.\n    - Enclose the curl request in triple backticks.\n    - Don't add extra \\\\\\\\ for strings.\n    - For DateTime fields, always use ISO 8601 format strings (e.g., \"2023-04-15T12:00:00Z\") and ensure they are properly quoted within the GraphQL query.\n    - When using date variables, format them as ISO 8601 strings.\n    - Escape double quotes within the JSON payload.\n    - The curl request follows apollo graphql client request format.\n    - Write efficient queries.\n\n    ---\n\n    Example output bash commands:\n     ---\n    curl -X POST -H \"Content-Type: application/json\" -d '{\n      \"query\": \"{ meetings(where: { id: 1 }) { id topic duration participantsAttended { user_name } } }\"\n    }' {{url}}\n    ---\n\n    Remember to always use proper ISO 8601 format for DateTime fields and escape quotes correctly in the JSON payload.\n\n   \n  \"#\n}\n\ntest TestName {\n  functions [GenerateGraphQLQuery]\n  args {\n    query #\"\n      Show me all the meetings that happened in the last 24 hours.\n    \"#\n    url #\"\n      http://localhost:4000\n    \"#\n    schema #\"\n     type Meeting {\n      duration: BigInt!\n      hasRecordings: [Recording!]! @relationship(type: \"HAS\", direction: OUT)\n      id: BigInt!\n      meeting_end_time: String\n      meeting_host_email: String\n      meeting_host_id: String\n      meeting_id: BigInt\n      meeting_start_time: String\n      meeting_topic: String\n      meeting_uuid: String\n      participantsAttended: [Participant!]! @relationship(type: \"ATTENDED\", direction: IN)\n      participants_count: BigInt!\n      start_time: DateTime!\n      summary_created_time: String\n      summary_end_time: String\n      summary_last_modified_time: String\n      summary_overview: String\n      summary_start_time: String\n      summary_title: String\n      topic: String!\n      total_minutes: BigInt!\n      type: BigInt!\n      usersHosted: [User!]! @relationship(type: \"HOSTED\", direction: IN)\n      uuid: String!\n    }\n\n    type Participant {\n      attendedMeetings: [Meeting!]! @relationship(type: \"ATTENDED\", direction: OUT)\n      audio_call: [String]!\n      audio_quality: String!\n      camera: String\n      connection_type: String\n      customer_key: String!\n      data_center: String!\n      device: String!\n      device_name: String!\n      domain: String!\n      email: String\n      from_sip_uri: String!\n      full_data_center: String!\n      groupId: String!\n      harddisk_id: String!\n      health: String!\n      id: String!\n      internal_ip_addresses: [String]\n      ip_address: String!\n      join_time: DateTime!\n      leave_reason: String!\n      leave_time: DateTime!\n      location: String!\n      mac_addr: String!\n      microphone: String\n      network_type: String!\n      os: String!\n      os_version: String!\n      participant_user_id: String\n      participant_uuid: String!\n      pc_name: String!\n      recording: Boolean!\n      registrant_id: String!\n      role: String!\n      screen_share_quality: String!\n      share_application: Boolean!\n      share_desktop: Boolean!\n      share_whiteboard: Boolean!\n      sip_uri: String!\n      speaker: String\n      status: String!\n      user_id: String!\n      user_name: String!\n      usersIs: [User!]! @relationship(type: \"IS\", direction: IN)\n      version: String!\n      video_quality: String!\n    }\n\n    type Recording {\n      download_url: String!\n      file_extension: String!\n      file_size: BigInt!\n      file_type: String!\n      id: String!\n      meeting_id: String!\n      meetingsHas: [Meeting!]! @relationship(type: \"HAS\", direction: IN)\n      play_url: String\n      recording_end: DateTime!\n      recording_start: DateTime!\n      recording_type: String!\n      status: String!\n    }\n\n    type User {\n      account_id: String!\n      account_number: BigInt!\n      cluster: String!\n      cms_user_id: String!\n      created_at: DateTime!\n      dept: String!\n      display_name: String!\n      email: String!\n      first_name: String!\n      group_ids: [String]!\n      hostedMeetings: [Meeting!]! @relationship(type: \"HOSTED\", direction: OUT)\n      id: String!\n      im_group_ids: [String]!\n      isParticipants: [Participant!]! @relationship(type: \"IS\", direction: OUT)\n      jid: String!\n      job_title: String!\n      language: String!\n      last_client_version: String!\n      last_login_time: DateTime!\n      last_name: String!\n      location: String!\n      login_types: [BigInt]!\n      personal_meeting_url: String!\n      phone_number: String!\n      pic_url: String!\n      pmi: BigInt!\n      role_id: String!\n      role_name: String!\n      status: String!\n      timezone: String!\n      type: BigInt!\n      use_pmi: Boolean!\n      user_created_at: DateTime!\n      vanity_url: String!\n      verified: BigInt!\n    }\n    \"#\n  }\n}\n",
  "interpret-result.baml": "function InterpretResult(query: string, result: string) -> string {\n  client Sonnet\n  prompt #\"\n\n    You are an AI assistant that interprets the result of a graphql query.\n    \n    User query:\n    {{ query }}\n\n    Database result:\n    {{ result}}\n\n    Please answer the user query based on the database result.\n  \"#\n}\n  ",
}
export const getBamlFiles = () => {
    return fileMap;
}